<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="title" style="text-align: center "><span><strong></strong>ImageLoader图片加载框架</span></span></div>
    <div class="content-info"> <span>2017年2月7日</span>/<span>thanatos</span>/<span>个人</span></div>
    <div class="text">
        <div style="text-indent: 2em">大家好，我是thanatos。这儿是我的个人博客，欢迎大家光临...</div><br>
        <div style="text-indent: 2em">我们在开发APP的时候都需要用到图片加载框架，在网上也同样能搜到一大片的图片加载框架，当我们使用这些框架的时候，难免也会用到网络
        加载数据框架，这就导致我们会使用两个或多个线程池，这样就会影响我们APP的性能，也不易进行线程管理所以为了项目的可管理性，我们可以
            自己写一个图片加载框架和网络请求框架，便于项目中线程的管理。</div><br>
        <h3>ImageLoader</h3>
        <h4>介绍：</h4>
        <div>支持加载网络和本地图片，加载网络图片使用了双缓存机制和libjpeg类库对图片进行处理，压缩比率可自由设置，加载本地图片使用了内存缓存机制，基本满足日常使用。</div>
        <h4>基本用法：</h4>
        <div>
            <br>
            <p>1.缓存:</p>
                <li>
                    ImageCache mCache=new MemeryCache();
                </li>
                <li>
                    ImageCache mCache=new MemeryCache();
                </li>
                <li>
                   ImageCache mCache=new MemeryCache();
                </li>
            <p style="margin-top: 1em">2.实例化ImageLoader</p>
            <li>ImageLoader imageLoader=ImageLoader.getInstance(mCache,true);//true:是否通过网络加载</li>
            <p style="margin-top: 1em">3.加载图片</p>
            <li>imageLoader.load("path",targetView);</li>
            <p style="margin-top: 1em">4.添加回调</p>
            <pre><code>imageLoader.callBack(new CallBack() {
                @Override
                public void start() {

                }

                @Override
                public void loading() {

                }

                @Override
                public void success() {

                }

                @Override
                public void error(int code) {

                }
                });</code></pre>
            <p style="margin-top: 1em">5.链式调用</p>
            <pre><code>ImageLoader.getInstance(new DoubleCache("fileName",60),false).load("path", (ImageView)
                holder.setView(R.id.iv_item_gallery_rv)).callBack(new CallBack() {
                @Override
                public void start() {

                }

                @Override
                public void loading() {

                }

                @Override
                public void success() {

                }

                @Override
                public void error(int code) {
                //code:responseCode
                }
                });</code></pre>

        </div>
        <h4>额外福利：</h4>
        <p>libjpeg的使用：</p>
            <pre><code>导入imageLoader Library库中的so库和android-jpeg.jar
            </code></pre>
            <pre><code>压缩bitmap: File file=new File("sdcard/"+cacheDir,MD5Utils.getMd5(path));
/**将图片处理后保存到本地
  *第一个参数是获取到的bitmap对象，
  *第二个参数是压缩比率
  *第三个参数是保存图片的路径
  *第四个参数是是否采用哈夫曼算法
  *（jpeg的核心算法，即谷歌在使用skia引擎的时候所阉割的，也是苹果处理图片和安卓处理图片的区别所在）
  */
NativeUtil.compressBitmap(bitmap,PERCENT,file.getAbsolutePath(),true);
            </code></pre>
        <h5>最后宣传下自己的博客中使用libjpeg的方法：</h5>
        <a target="_blank" href="http://blog.csdn.net/qq_16070781/article/details/54288269">http://blog.csdn.net/qq_16070781/article/details/54288269</a><br>
        <p>源代码：
        <a target="_blank" href="https://github.com/waws80/Utils">欢迎大家去我的github多start</a>
        </p>
    </div>
</body>
</html>